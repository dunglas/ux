# Symfony UX Turbo

Symfony UX Turbo a Symfony bundle integrating the [Hotwire Turbo](https://turbo.hotwire.dev)
library in Symfony applications. It is part of [the Symfony UX initiative](https://symfony.com/ux).

Symfony UX Turbo allow having the same user experience as with [Single Page Apps](https://en.wikipedia.org/wiki/Single-page_application)
but without having to write a single line of JavaScript!

Symfony UX Turbo also integrates with [Symfony Mercure](https://symfony.com/doc/current/mercure.html) to broadcast DOM changes
to  all currently connected users!

You're in a hurry? Take a look to [the chat example](#sending-async-changes-using-mercure-a-chat) to discover the full potential
of Symfony UX Turbo.

## Installation

Symfony UX Turbo requires PHP 8+ and Symfony 4.4+.

Install this bundle using Composer and Symfony Flex:

```sh
composer require symfony/ux-turbo

# Don't forget to install the JavaScript dependencies as well and compile
yarn install --force
yarn encore dev
```

## Usage

### Accelerating Navigation with Turbo Drive

Turbo Drive enhances page-level navigation. It watches for link clicks and form submissions,
performs them in the background, and updates the page without doing a full reload.

Turbo Drive is automatically enabled when you install Symfony UX Turbo.

[Read the Turbo Drive documentation](https://turbo.hotwire.dev/handbook/drive) to learn about the advanced features offered
by Turbo Drive.

### Decomposing Complex Pages with Turbo Frames

Symfony UX Turbo contains convenient helpers to create [Turbo Frames](https://turbo.hotwire.dev/handbook/introduction#turbo-frames-decompose-complex-pages).

To wrap some content in a Turbo Frame, use the `turbo_frame_start()` and `turbo_frame_stop()` helper functions:

```twig
{# home.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    {{ turbo_frame_start('the_frame_id }}
        <a href="{{ path('another-page') }}">This block is scoped, the rest of the page will not change if you click here!</a>
    {{ turbo_frame_end() }}
{% endblock %}
```

```twig
{# another-page.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    <div>This will be discarded</div>

    {{ turbo_frame_start('the_frame_id') }}
        The content of this block will replace the content of the Turbo Frame!
        The rest of the HTML generated by this template (outside of the Turbo Frame) will be ignored.
    {{ turbo_frame_end() }}
{% endblock %}
```

You can also lazy load the content of a frame:

```twig
{# home.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    {{ turbo_frame_start('the_frame_id , { src: path('block') }}} {# you can set extra attributes using this map #}
        A placeholder.
    {{ turbo_frame_end() }}
{% endblock %}
```

In your controller, you can detect if the request has been triggered by a Turbo Frame, and retrieve the ID of this frame:

```php
// src/Controller/MyController.php
namespace App\Controller;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class MyController
{
    #[Route('/')]
    public function home(Request $request): Response
    {
        // Get the frame ID (will be null if the request hasn't been triggered by a Turbo Frame)
        $frameId = $request->headers->get('Turbo-Frame');

        // ...
    }
}
```

[Read the Turbo Frames documentation](https://turbo.hotwire.dev/handbook/frames) to learn everything you can do using Turbo Frames.

### Coming Alive with Turbo Streams

Turbo Streams are a way for the server to send partial page updates to clients.
There are two main way to receive the updates:

* in response to a user action, for instance when the user submits a form
* asynchronously, by sending updates to the clients using [Mercure](https://mercure.rocks), [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) and similar protocols

#### Forms

Let's discover how to use Turbo Streams to enhance your [Symfony forms](https://symfony.com/doc/current/forms.html):

```php
// src/Controller/TaskController.php
namespace App\Controller;

// ...
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\UX\Turbo\Stream\TurboStreamResponse;
use Symfony\UX\Turbo\TurboBundle;

class TaskController extends AbstractController
{
    public function new(Request $request): Response
    {
        $task = new Task();

        $form = $this->createForm(TaskType::class, $task);

        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {
            $task = $form->getData();
            // ... perform some action, such as saving the task to the database

            // ðŸ”¥ The magic happens here! ðŸ”¥
            if (TurboBundle::STREAM_FORMAT === $request->getPreferredFormat()) {
                // If the request comes from Turbo, only send the HTML to update using a TurboStreamResponse
                return $this->render('task/success.stream.html.twig', ['task' => $task], new TurboStreamResponse());
            }

            // If the client doesn't support JavaScript, or isn't using Turbo, the form still works as usual.
            // Symfony UX Turbo is all about progressively enhancing your apps!
            return $this->redirectToRoute('task_success');
        }

        return $this->render('task/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
}
```

```twig
{# success.stream.html.twig #}

{{ turbo_stream_start("replace", "my_div_id") }}
    The element having the id "my_div_id" will be replace by this block, without a full page reload!

    <div>The task "{{ task }}" has been created!</div>
{{ turbo_stream_end() }}
```

Supported actions are `append`, `prepend`, `replace`,  `update` and `remove`.
[Read the Turbo Streams documentation for more details](https://turbo.hotwire.dev/handbook/streams).

#### Sending Async Changes using Mercure: a Chat

Symfony UX Turbo also supports the [Mercure](https://mercure.rocks) protocol. With this feature you can broadcast HTML
updates to all currently connected clients.

To illustrate this, let's build a chat system in **0 lines of JavaScript**!

Start by installing [the Mercure support](https://symfony.com/doc/current/mercure.html) on your project.
The easiest way to have a working development (and production-ready) environment is to use [Symfony Docker](https://github.com/dunglas/symfony-docker/),
which comes with a Mercure hub integrated in the web server.

If you use Symfony Flex, the configuration has been generated for you, be sure to update the `MERCURE_SUBSCRIBE_URL` in
the `.env` file to point a Mercure Hub (it's not necessary if you are using Symfony Docker).

Otherwise, configure the URL of the Mercure Hub:

```yaml
# config/packages/turbo.yaml
turbo:
    mercure:
        subscribe_url: https://localhost/.well-known/mercure
```

Let's create our chat:

```php
// src/Controller/ChatController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;use Symfony\Component\Form\Extension\Core\Type\TextType;use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mercure\PublisherInterface;

class ChatController extends AbstractController
{
    public function chat(Request $request, PublisherInterface $mercure): Response
    {
        $form = $this->createFormBuilder()
            ->add('message', TextType::class, ['attr' => ['autocomplete' => 'off']])
            ->add('send', SubmitType::class)
            ->getForm();

        $newForm = clone $form; // Used display an empty message box after a post
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $data = $form->getData();

            // ðŸ”¥ The magic happens here! ðŸ”¥
            // The HTML update is pushed to the client using Mercure
            // The Mercure topic (here "chat") MUST be the ID of the block that will display the received updates
            $mercure(new Update(
                'chat',
                $this->renderView('chat/message.stream.html.twig', ['message' => $data['message']])
            ));
        }

        return $this->render('chat/index.html.twig', 
            ['form' => $newForm->createView() // Always display an empty form, it will replace the content of the Turbo Frame after a post
         ]);
    }
}
```

```twig
{# chat/chat.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    <h1>Chat</h1>

    {{ turbo_stream_from('chat') }}
        <div id="messages">
            {#
                The messages will be displayed here.
                "turbo_stream_from()" automatically registers a Stimulus controller that subscribes to the "chat" Mercure topic using EventSource.
                The connection to the Mercure Hub is automatically closed when this HTML block is removed.
        
                All connected users will receive the new messages!
             #}
        </div>
    {{ turbo_stream_from_end() }}

    {{ turbo_frame_start('message_form') }}
        {{ form(form) }}

        {# 
            The form is displayed in a Turbo Frame, with this trick a new empty form is displayed after every post,
            but the rest of the page will not change.
        #}
    {{ turbo_frame_end() }}
{% endblock %}
```

```twig
{# chat/message.stream.html.twig #}

{# New messages received through the Mercure connection are appended to the div with the "messages" ID in the "turbo_stream_from" block. #}
{{ turbo_stream_start('append', 'messages') }}
    <div>{{ message }}</div>
{{ turbo_stream_end() }}
```

Keep in mind that you can use all features provided by Symfony Mercure, including [private updates](https://symfony.com/doc/current/mercure.html#authorization)
(to ensure that only  authorized users will receive the updates) and [async dispatching with Symfony Messenger](https://symfony.com/doc/current/mercure.html#async-dispatching).

#### Broadcast Doctrine Entities Update

Symfony UX Turbo also comes with a convenient integration with Doctrine ORM.

With a single attribute, your clients can subscribe to creation, update and deletion of entities.

```php
// src/Entity/Book.php
namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\UX\Turbo\Broadcast;

/**
 * @ORM\Entity
 */
#[Broadcast] // ðŸ”¥ The magic happens here
class Book
{
    /**
     * @ORM\Column(type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    public ?int $id = null;

    /**
     * @ORM\Column
     */
    public string $title = '';
}
```

To subscribe to the updates, use the `turbo_stream_from()` Twig helper and pass the Fully Qualified Class Name of the entity as parameter:

```twig
{{ turbo_stream_from('App\\Entity\\Book') }}
    <div id="books"></div>
{{ turbo_stream_from_end() }}
```

Every time an entity marked with the `Broadcast` attribute changes, Symfony UX Turbo uses Mercure to publish an HTML update.

By convention, Symfony UX Turbo will look for templates rendering the HTML fragment to broadcast in the following directories:

* entities in the `App\Entity` namespace: `templates/broadcast/{ClassName}/` (ex: `templates/broadcast/Book/`)
* other classes: `templates/broadcast/{Fully}/{Qualified}/{ClassName}/`  (ex: `templates/broadcast/An/Other/Class/`)

Tip: if your entities aren't in the `App\Entity` namespace, you can configure change the list of prefixes to strip with
the `turbo.broadcast.strip_prefixes` configuration parameter.

In this directory, Symfony UX Turbo will render the following templates:

* `create.html.twig`: HTML fragment to send when an entity is created 
* `update.html.twig`: HTML fragment to send when an entity is updated 
* `remove.html.twig`: HTML fragment to send when an entity is removed 

The current entity, the action (`create`, `update` or `remove`) and options set on the `Broadcast` attribute
are passed to the template respectively as `entity`, `action` and `options` variables.

The template must render a list of Turbo Stream actions. These actions will be sent to all connected clients and applied
to their DOM trees. Each template can contain as many actions as needed.
For instance, if the same entity is displayed in different pages or blocks, you can include all actions updating these
different places. Actions applying to non-existing DOM will simply be ignored.

Example for our entity:

```twig
{# templates/broadcast/Book/create.stream.html.twig #}
{{ turbo_stream_start('append', 'books') }}
    {# You'll probably prefer to use an include here #}
    <div id="{{ 'book_' ~ entity.id }}">{{ entity.title }} (#{{ entity.id }})</div>
{{ turbo_stream_end() }}
```

```twig
{# templates/broadcast/Book/update.stream.html.twig #}
{{ turbo_stream_start('update', 'book_' ~ entity.id) }}
    {# You'll probably prefer to use an include here #}
    {{ entity.title }} (#{{ entity.id }}, updated)
{{ turbo_stream_end() }}
```

```twig
{# templates/broadcast/Book/remove.stream.html.twig #}
{{ turbo_stream_start('remove', 'book_' ~ entity.id) }}{{ turbo_stream_end() }}
```

The `Broadcast` attribute comes with a set of handy options:

* `topics` (`string[]` Mercure topics to use, defaults to an array containing the Fully Qualified Class Name with "\" characters replaced by ":" characters
* `createTemplate` (`string`) The Twig template to render when a new object is created
* `updateTemplate` (`string`) The Twig template to render when a new object is updated
* `removeTemplate` (`string`) The Twig template to render when a new object is removed
* `private` (`bool`) Marks Mercure updates as private
* `id` (`string`) ID field of the SSE
* `type` (`string`) type field of the SSE
* `retry` (`int`) retry field of the SSE

Example:

```php
// src/Entity/Book.php
namespace App\Entity;

use Symfony\UX\Turbo\Broadcast;

#[Broadcast(createTemplate: 'foo.stream.html.twig', private: true)]
class Book
{
    // ...
}
```

If the [Symfony ExpressionLanguage Component](https://symfony.com/doc/current/components/expression_language.html) is installed,
you can also pass an *expression* generating the options as parameter of the `Broadcast` attribute:


```php
// src/Entity/Book.php
namespace App\Entity;

use Symfony\UX\Turbo\Broadcast;

#[Broadcast('entity.getOptions()')]
class Book
{
    // ...

    public function getOptions(): array
    {
        return [
            'topics' => [$this->id],
            'private' => $this->private,
        ];
    }
}
```

## Backward Compatibility promise

This bundle aims at following the same Backward Compatibility promise as the Symfony framework:
[https://symfony.com/doc/current/contributing/code/bc.html](https://symfony.com/doc/current/contributing/code/bc.html)

However, it is currently considered
[**experimental**](https://symfony.com/doc/current/contributing/code/experimental.html),
meaning it is not bound to Symfony's BC policy for the moment.

## Run tests

### PHP tests

```sh
php vendor/bin/simple-phpunit
```

### JavaScript tests

```sh
cd Resources/assets
yarn test
```
