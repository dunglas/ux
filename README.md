# Symfony UX Turbo

Symfony UX Turbo a Symfony bundle integrating the [Hotwire Turbo](https://turbo.hotwire.dev)
library in Symfony applications. It is part of [the Symfony UX initiative](https://symfony.com/ux).

Symfony UX Turbo allow having the same user experience as with [Single Page Apps](https://en.wikipedia.org/wiki/Single-page_application)
but without having to write a single line of JavaScript!

Symfony UX Turbo also integrates with [Symfony Mercure](https://symfony.com/doc/current/mercure.html) to DOM changes to
all currently connected users!

You're in a hurry? Take a look to [the chat example](#sending-async-changes-using-mercure-a-chat) to discover the full potential of Symfony UX Turbo.

## Installation

Symfony UX Turbo requires PHP 8+ and Symfony 4.4+.

Install this bundle using Composer and Symfony Flex:

```sh
composer require symfony/ux-turbo

# Don't forget to install the JavaScript dependencies as well and compile
yarn install --force
yarn encore dev
```

## Usage

### Decompose Complex Pages with Turbo Frames

Symfony UX Turbo contains convenient helpers to create [Turbo Frames](https://turbo.hotwire.dev/handbook/introduction#turbo-frames-decompose-complex-pages).

To wrap some content in a Turbo Frame, use the `turbo_frame_start()` and `turbo_frame_stop()` helper functions:

```twig
{# home.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    {{ turbo_frame_start('the_frame_id }}
        <a href="{{ path('another-page') }}">This block is scoped, the rest of the page will not change if you click here!</a>
    {{ turbo_frame_end() }}
{% endblock %}
```

```twig
{# another-page.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    <div>This will be discarded</div>

    {{ turbo_frame_start('the_frame_id') }}
        The content of this block will replace the content of the Turbo Frame!
        The rest of the HTML generated by this template (outside of the Turbo Frame) will be ignored.
    {{ turbo_frame_end() }}
{% endblock %}
```

You can also lazy load the content of a frame:

```twig
{# home.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    {{ turbo_frame_start('the_frame_id , { src: path('block') }}} {# you can set extra attributes using this map #}
        A placeholder.
    {{ turbo_frame_end() }}
{% endblock %}
```

In your controller, you can detect if the request has been triggered by a Turbo Frame, and retrieve the ID of this frame:

```php
// src/Controller/MyController.php
namespace App\Controller;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class MyController
{
    #[Route('/')]
    public function home(Request $request): Response
    {
        // Get the frame ID (will be null if the request hasn't been triggered by a Turbo Frame)
        $frameId = $request->headers->get('Turbo-Frame');

        // ...
    }
}
```

[Read the Turbo Frames documentation](https://turbo.hotwire.dev/handbook/frames) to learn everything you can do using Turbo Frames.

### Come Alive with Turbo Streams

Turbo Streams are a way for the server to send partial page updates to clients.
There are two main way to receive the updates:

* in response to a user action, for instance when the user submits a form
* asynchronously, by sending updates to the clients using [Mercure](https://mercure.rocks), [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) and similar protocols

#### Forms

Let's discover how to use Turbo Streams to enhance your [Symfony forms](https://symfony.com/doc/current/forms.html):

```php
// src/Controller/TaskController.php
namespace App\Controller;

// ...
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\UX\Turbo\Stream\TurboStreamResponse;
use Symfony\UX\Turbo\TurboBundle;

class TaskController extends AbstractController
{
    public function new(Request $request): Response
    {
        $task = new Task();

        $form = $this->createForm(TaskType::class, $task);

        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {
            $task = $form->getData();
            // ... perform some action, such as saving the task to the database

            // ðŸ”¥ The magic happens here! ðŸ”¥
            if (TurboBundle::STREAM_FORMAT === $request->getPreferredFormat()) {
                // If the request comes from Turbo, only send the HTML to update using a TurboStreamResponse
                return $this->render('task/success.stream.html.twig', ['task' => $task], new TurboStreamResponse());
            }

            // If the client doesn't support JavaScript, or isn't using Turbo, the form still works as usual.
            // Symfony UX Turbo is all about progressively enhancing your apps!
            return $this->redirectToRoute('task_success');
        }

        return $this->render('task/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
}
```

```twig
{# success.stream.html.twig #}

{{ turbo_stream_start("replace", "my_div_id") }}
    The element having the id "my_div_id" will be replace by this block, without a full page reload!

    <div>The task "{{ task }}" has been created!</div>
{{ turbo_stream_end() }}
```

Supported actions are `append`, `prepend`, `replace`,  `update` and `remove`.
[Read the Turbo Streams documentation for more details](https://turbo.hotwire.dev/handbook/streams).

#### Sending Async Changes using Mercure: a Chat

Symfony UX Turbo also supports the [Mercure](https://mercure.rocks) protocol. With this feature you can broadcast HTML
updates to all currently connected clients.

To illustrate this, let's build a chat system in **0 lines of JavaScript**!

Start by installing [the Mercure support](https://symfony.com/doc/current/mercure.html) on your project.
The easiest way to have a working development (and production-ready) environment is to use [Symfony Docker](https://github.com/dunglas/symfony-docker/),
which comes with a Mercure hub integrated in the web server.

```php
// src/Controller/ChatController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;use Symfony\Component\Form\Extension\Core\Type\TextType;use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mercure\PublisherInterface;

class ChatController extends AbstractController
{
    public function chat(Request $request, PublisherInterface $mercure): Response
    {
        $form = $this->createFormBuilder()
            ->add('message', TextType::class, ['attr' => ['autocomplete' => 'off']])
            ->add('send', SubmitType::class)
            ->getForm();

        $newForm = clone $form; // Used display an empty message box after a post
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $data = $form->getData();

            // ðŸ”¥ The magic happens here! ðŸ”¥
            // The HTML update is pushed to the client using Mercure
            // The Mercure topic (here "chat") MUST be the ID of the block that will display the received updates
            $mercure(new Update(
                'chat',
                $this->renderView('chat/message.stream.html.twig', ['message' => $data['message']])
            ));
        }

        return $this->render('chat/index.html.twig', 
            ['form' => $newForm->createView() // Always display an empty form, it will replace the content of the Turbo Frame after a post
         ]);
    }
}
```

```twig
{# chat/chat.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    <h1>Chat</h1>

    {{ turbo_stream_from('chat') }}
    {#
        The messages will be displayed here.
        "turbo_stream_from" automatically registers a Stimulus controller that subscribes to the Mercure topic using EventSource.
        The connection to the Mercure Hub is automatically closed when this HTML block is removed.

        All connected users will receive the new messages!
     #}
    {{ turbo_stream_from_end() }}

    {{ turbo_frame_start('message_form') }}
        {{ form(form) }}

        {# 
            The form is displayed in a Turbo Frame, with this trick a new empty form is displayed after every post,
            but the rest of the page will not change.
        #}
    {{ turbo_frame_end() }}
{% endblock %}
```

```twig
{# chat/message.stream.html.twig #}

{# New messages received through the Mercure connection are appended to the "tubo_stream_from" block having the "chat" ID. #}
{{ turbo_stream_start('append', 'chat') }}
<div>{{ message }}</div>
{{ turbo_stream_end() }}
```

And keep in mind that you can use all features provided by Symfony Mercure, including [private updates](https://symfony.com/doc/current/mercure.html#authorization) (to ensure that only
authorized users will receive the updates) and [async dispatching with Symfony Messenger](https://symfony.com/doc/current/mercure.html#async-dispatching).

#### Broadcast Doctrine Entities Update

Symfony UX Turbo also comes with a convenient integration with Doctrine ORM.

With a single attribute, your clients can subscribe to creation, update and deletion of entities.

```php
// src/Entity/Book.php
namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\UX\Turbo\Broadcast;

/**
 * @ORM\Entity
 */
#[Broadcast] // ðŸ”¥ The magic happens here
class Book
{
    /**
     * @ORM\Column(type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    public ?int $id = null;

    /**
     * @ORM\Column
     */
    public string $title = '';
}
```

To subscribe to the updates, use this Twig helper:

```twig
{{ turbo_stream_from('App\\Entity\\Book') }}
{{ turbo_stream_from_end() }}
```

Every time an entity marked with the `Broadcast` attribute changes, Symfony UX Turbo uses Mercure to publish an HTML update.
By convention, Symfony UX Turbo will renders a template named `broadcast/{Fully:Qualified:Class:Name}.stream.html.twig`.
It passes the entity as well as the action (`create`, `update` or `remove`) to the template.

Example for our entity:

```twig
{# templats/broadcast/App:Entity:Book.stream.html.twig #}

{% set id = 'book_' ~ entity.id %}

{% if action == 'create' %}
    {{ turbo_stream_start('append', 'App\\Entity\\Book') }}
        <div id="{{ id }}">{{ entity.title }} (#{{ entity.id }})</div>
    {{ turbo_stream_end() }}
{% endif %}

{% if action == 'update' %}
    {{ turbo_stream_start('update', id) }}
        {{ entity.title }} (#{{ entity.id }}, updated)
    {{ turbo_stream_end() }}
{% endif %}

{% if action == 'remove' %}
    {{ turbo_stream_start('remove', id) }}{{ turbo_stream_end() }}
{% endif %}
```

TODO: document all options of this feature

## Backward Compatibility promise

This bundle aims at following the same Backward Compatibility promise as the Symfony framework:
[https://symfony.com/doc/current/contributing/code/bc.html](https://symfony.com/doc/current/contributing/code/bc.html)

However, it is currently considered
[**experimental**](https://symfony.com/doc/current/contributing/code/experimental.html),
meaning it is not bound to Symfony's BC policy for the moment.

## Run tests

### PHP tests

```sh
php vendor/bin/simple-phpunit
```

### JavaScript tests

```sh
cd Resources/assets
yarn test
```
