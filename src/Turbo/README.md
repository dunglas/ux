# Symfony UX Turbo

Symfony UX Turbo is a Symfony bundle integrating the [Hotwire Turbo](https://turbo.hotwire.dev)
library in Symfony applications. It is part of [the Symfony UX initiative](https://symfony.com/ux).

Symfony UX Turbo allow having the same user experience as with [Single Page Apps](https://en.wikipedia.org/wiki/Single-page_application)
but without having to write a single line of JavaScript!

Symfony UX Turbo also integrates with [Symfony Mercure](https://symfony.com/doc/current/mercure.html) to broadcast DOM changes
to all currently connected users!

You're in a hurry? Take a look to [the chat example](#sending-async-changes-using-mercure-a-chat) to discover the full potential
of Symfony UX Turbo.

## Installation

Symfony UX Turbo requires PHP 8+ and Symfony 4.4+.

Install this bundle using Composer and Symfony Flex:

```sh
composer require symfony/ux-turbo

# Don't forget to install the JavaScript dependencies as well and compile
yarn install --force
yarn encore dev
```

## Usage

### Accelerating Navigation with Turbo Drive

Turbo Drive enhances page-level navigation. It watches for link clicks and form submissions,
performs them in the background, and updates the page without doing a full reload.

Turbo Drive is automatically enabled when you install Symfony UX Turbo.

[Read the Turbo Drive documentation](https://turbo.hotwire.dev/handbook/drive) to learn about the advanced features offered
by Turbo Drive.

### Decomposing Complex Pages with Turbo Frames

Symfony UX Turbo contains convenient helpers to create [Turbo Frames](https://turbo.hotwire.dev/handbook/introduction#turbo-frames-decompose-complex-pages).

To wrap some content in a Turbo Frame, use the `turbo_frame_start()` and `turbo_frame_end()` helper functions:

```twig
{# home.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    {{ turbo_frame_start('the_frame_id') }}
        <a href="{{ path('another-page') }}">This block is scoped, the rest of the page will not change if you click here!</a>
    {{ turbo_frame_end() }}
{% endblock %}
```

```twig
{# another-page.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    <div>This will be discarded</div>

    {{ turbo_frame_start('the_frame_id') }}
        The content of this block will replace the content of the Turbo Frame!
        The rest of the HTML generated by this template (outside of the Turbo Frame) will be ignored.
    {{ turbo_frame_end() }}
{% endblock %}
```

You can also lazy load the content of a frame:

```twig
{# home.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    {{ turbo_frame_start('the_frame_id', { src: path('block') })}} {# you can set extra attributes using this map #}
        A placeholder.
    {{ turbo_frame_end() }}
{% endblock %}
```

In your controller, you can detect if the request has been triggered by a Turbo Frame, and retrieve the ID of this frame:

```php
// src/Controller/MyController.php
namespace App\Controller;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class MyController
{
    #[Route('/')]
    public function home(Request $request): Response
    {
        // Get the frame ID (will be null if the request hasn't been triggered by a Turbo Frame)
        $frameId = $request->headers->get('Turbo-Frame');

        // ...
    }
}
```

#### Writing Tests

Under the hood, Symfony UX Turbo relies on JavaScript to update the HTML page.
To test if your website works properly, you will have to write [UI tests](https://martinfowler.com/articles/practical-test-pyramid.html#UiTests).

Fortunately, we've got you covered! [Symfony Panther](https://github.com/symfony/panther) is a convenient testing tool
using real browsers to test your Symfony application. It shares the same API as BrowserKit, the functional testing tool shipped with Symfony.

[Install Symfony Panther](https://github.com/symfony/panther#installing-panther), and write a test for our Turbo Frame:

```php
// tests/TurboFrameTest.php
namespace App\Tests;

use Symfony\Component\Panther\PantherTestCase;

class TurboFrameTest extends PantherTestCase
{
    public function testFrame(): void
    {
        $client = self::createPantherClient();
        $client->request('GET', '/');

        $client->clickLink('This block is scoped, the rest of the page will not change if you click here!');
        $this->assertSelectorTextContains('body', 'This will replace the content of the Turbo Frame!');
    }
}
```

Run `bin/phpunit` to execute the test! Symfony Panther automatically starts your application with a web server
and test it using Google Chrome (Firefox is also supported)!

You can even watch changes happening in Chrome by using: `PANTHER_NO_HEADLESS=1 bin/phpunit --debug`

[Read the Turbo Frames documentation](https://turbo.hotwire.dev/handbook/frames) to learn everything you can do using Turbo Frames.

### Coming Alive with Turbo Streams

Turbo Streams are a way for the server to send partial page updates to clients.
There are two main way to receive the updates:

-   in response to a user action, for instance when the user submits a form
-   asynchronously, by sending updates to clients using [Mercure](https://mercure.rocks), [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) and similar protocols

#### Forms

Let's discover how to use Turbo Streams to enhance your [Symfony forms](https://symfony.com/doc/current/forms.html):

```php
// src/Controller/TaskController.php
namespace App\Controller;

// ...
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\UX\Turbo\Stream\TurboStreamResponse;

class TaskController extends AbstractController
{
    public function new(Request $request): Response
    {
        $task = new Task();

        $form = $this->createForm(TaskType::class, $task);

        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {
            $task = $form->getData();
            // ... perform some action, such as saving the task to the database

            // ðŸ”¥ The magic happens here! ðŸ”¥
            if (TurboStreamResponse::STREAM_FORMAT === $request->getPreferredFormat()) {
                // If the request comes from Turbo, only send the HTML to update using a TurboStreamResponse
                return $this->render('task/success.stream.html.twig', ['task' => $task], new TurboStreamResponse());
            }

            // If the client doesn't support JavaScript, or isn't using Turbo, the form still works as usual.
            // Symfony UX Turbo is all about progressively enhancing your apps!
            return $this->redirectToRoute('task_success');
        }

        return $this->render('task/new.html.twig', [
            'form' => $form->createView(),
        ]);
    }
}
```

```twig
{# success.stream.html.twig #}

{{ turbo_stream_start("replace", "my_div_id") }}
    The element having the id "my_div_id" will be replace by this block, without a full page reload!

    <div>The task "{{ task }}" has been created!</div>
{{ turbo_stream_end() }}
```

Supported actions are `append`, `prepend`, `replace`, `update` and `remove`.
[Read the Turbo Streams documentation for more details](https://turbo.hotwire.dev/handbook/streams).

#### Sending Async Changes using Mercure: a Chat

Symfony UX Turbo also supports the [Mercure](https://mercure.rocks) protocol. With this feature you can broadcast HTML
updates to all currently connected clients.

To illustrate this, let's build a chat system with **0 lines of JavaScript**!

Start by installing [the Mercure support](https://symfony.com/doc/current/mercure.html) on your project.
The easiest way to have a working development (and production-ready) environment is to use [Symfony Docker](https://github.com/dunglas/symfony-docker/),
which comes with a Mercure hub integrated in the web server.

If you use Symfony Flex, the configuration has been generated for you, be sure to update the `MERCURE_SUBSCRIBE_URL` in
the `.env` file to point to a Mercure Hub (it's not necessary if you are using Symfony Docker).

Otherwise, configure the URL of the Mercure Hub:

```yaml
# config/packages/turbo.yaml
turbo:
    mercure:
        subscribe_url: https://localhost/.well-known/mercure
```

Let's create our chat:

```php
// src/Controller/ChatController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Form\Extension\Core\Type\SubmitType;use Symfony\Component\Form\Extension\Core\Type\TextType;use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Mercure\PublisherInterface;

class ChatController extends AbstractController
{
    public function chat(Request $request, PublisherInterface $mercure): Response
    {
        $form = $this->createFormBuilder()
            ->add('message', TextType::class, ['attr' => ['autocomplete' => 'off']])
            ->add('send', SubmitType::class)
            ->getForm();

        $emptyForm = clone $form; // Used display an empty form after a post
        $form->handleRequest($request);

        if ($form->isSubmitted() && $form->isValid()) {
            $data = $form->getData();

            // ðŸ”¥ The magic happens here! ðŸ”¥
            // The HTML update is pushed to the client using Mercure
            // The Mercure topic (here "chat") MUST be the ID of the block that will display the received updates
            $mercure(new Update(
                'chat',
                $this->renderView('chat/message.stream.html.twig', ['message' => $data['message']])
            ));

            // Force an empty form to be rendered below
            // It will replace the content of the Turbo Frame after a post
            $form = $emptyForm;
        }

        return $this->render('chat/index.html.twig',
            ['form' => $form->createView()
         ]);
    }
}
```

```twig
{# chat/index.html.twig #}
{% extends 'base.html.twig' %}

{% block body %}
    <h1>Chat</h1>

    {{ turbo_stream_from_start('chat') }}
        <div id="messages">
            {#
                The messages will be displayed here.
                "turbo_stream_from_start()" automatically registers a Stimulus controller that subscribes to the "chat" Mercure topic using EventSource.
                The connection to the Mercure Hub is automatically closed when this HTML block is removed.

                All connected users will receive the new messages!
             #}
        </div>
    {{ turbo_stream_from_end() }}

    {{ turbo_frame_start('message_form') }}
        {{ form(form) }}

        {#
            The form is displayed in a Turbo Frame, with this trick a new empty form is displayed after every post,
            but the rest of the page will not change.
        #}
    {{ turbo_frame_end() }}
{% endblock %}
```

```twig
{# chat/message.stream.html.twig #}

{# New messages received through the Mercure connection are appended to the div with the "messages" ID in the "turbo_stream_from" block. #}
{{ turbo_stream_start('append', 'messages') }}
    <div>{{ message }}</div>
{{ turbo_stream_end() }}
```

Keep in mind that you can use all features provided by Symfony Mercure, including [private updates](https://symfony.com/doc/current/mercure.html#authorization)
(to ensure that only authorized users will receive the updates) and [async dispatching with Symfony Messenger](https://symfony.com/doc/current/mercure.html#async-dispatching).

#### Broadcast Doctrine Entities Update

Symfony UX Turbo also comes with a convenient integration with Doctrine ORM.

With a single attribute, your clients can subscribe to creation, update and deletion of entities:

```php
// src/Entity/Book.php
namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\UX\Turbo\Broadcast;

/**
 * @ORM\Entity
 */
#[Broadcast] // ðŸ”¥ The magic happens here
class Book
{
    /**
     * @ORM\Column(type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    public ?int $id = null;

    /**
     * @ORM\Column
     */
    public string $title = '';
}
```

To subscribe to updates, use the `turbo_stream_from_start()` Twig helper and pass the Fully Qualified Class Name of the entity as parameter:

```twig
{{ turbo_stream_from_start('App\\Entity\\Book') }}
    <div id="books"></div>
{{ turbo_stream_from_end() }}
```

Finally, create the template that will be rendered when an entity is created, modified or deleted:

```twig
{# templates/broadcast/Book.stream.html.twig #}
{% block create %}
    {{ turbo_stream_start('append', 'books') }}
        <div id="{{ 'book_' ~ entity.id }}">{{ entity.title }} (#{{ entity.id }})</div>
    {{ turbo_stream_end() }}
{% endblock %}

{% block update %}
    {{ turbo_stream_start('update', 'book_' ~ entity.id) }}
        {{ entity.title }} (#{{ entity.id }}, updated)
    {{ turbo_stream_end() }}
{% endblock %}

{% block remove %}
    {{ turbo_stream_start('remove', 'book_' ~ entity.id) }}{{ turbo_stream_end() }}
{% endblock %}
```

By convention, Symfony UX Turbo will look for a template named `templates/broadcast/{ClassName}.stream.html.twig`.
This template **must** contain at least 3 blocks: `create`, `update` and `remove` (they can be empty, but they must exist).

Every time an entity marked with the `Broadcast` attribute changes, Symfony UX Turbo will render the associated template
and will use Mercure to broadcast the changes to all connected clients.

Each block must contain a list of Turbo Stream actions. These actions will be automatically applied by Turbo to the DOM
tree of every connected client. Each template can contain as many actions as needed.

For instance, if the same entity is displayed on different pages, you can include all actions updating these different places
in the template.
Actions applying to non-existing DOM elements will simply be ignored.

The current entity, the action (`create`, `update` or `remove`) and options set on the `Broadcast` attribute
are passed to the template as variables: `entity`, `action` and `options`.

### Broadcast Template Conventions and Configuration

If your entities aren't in the `App\Entity` namespace, Symfony UX Turbo will look for a template in a directory named after
their Fully Qualified Class Names. For instance, if a class marked with the `Broadcast` attribute is named `\App\Foo\Bar`,
the corresponding template will be `templates/broadcast/App/Foo/Bar.stream.html.twig`.

It's possible to use the `turbo.broadcast.entity_namespace` configuration parameter to change the default entity namespace:

```yaml
# config/packages/turbo.yaml
turbo:
    broadcast:
        entity_namespace: App\Foo
```

Finally, it's also possible to explicitly set the template to use with the `template` parameter of the `Broadcast` attribute:

```php
#[Broadcast(template: 'my-template.stream.html.twig')]
class Book { /* ... */ }
```

### Broadcast Options

The `Broadcast` attribute comes with a set of handy options:

-   `template` (`string`): Twig template to render (see above)
-   `topics` (`string[]`): Mercure topics to use, defaults to an array containing the Fully Qualified Class Name
-   `private` (`bool`): marks Mercure updates as private
-   `id` (`string`): `id` field of the SSE
-   `type` (`string`): `type` field of the SSE
-   `retry` (`int`): `retry` field of the SSE

Example:

```php
// src/Entity/Book.php
namespace App\Entity;

use Symfony\UX\Turbo\Broadcast;

#[Broadcast(template: 'foo.stream.html.twig', private: true)]
class Book
{
    // ...
}
```

### Using an Expression to Generate The Options

If the [Symfony ExpressionLanguage Component](https://symfony.com/doc/current/components/expression_language.html) is installed,
you can also pass an _expression_ generating the options as parameter of the `Broadcast` attribute:

```php
// src/Entity/Book.php
namespace App\Entity;

use Symfony\UX\Turbo\Broadcast;

#[Broadcast('entity.getOptions()')]
class Book
{
    // ...

    public function getOptions(): array
    {
        return [
            'topics' => [$this->id],
            'private' => $this->private,
        ];
    }
}
```

## Backward Compatibility promise

This bundle aims at following the same Backward Compatibility promise as the Symfony framework:
[https://symfony.com/doc/current/contributing/code/bc.html](https://symfony.com/doc/current/contributing/code/bc.html)

However, it is currently considered
[**experimental**](https://symfony.com/doc/current/contributing/code/experimental.html),
meaning it is not bound to Symfony's BC policy for the moment.

## Credits

Created by [KÃ©vin Dunglas](https://dunglas.fr). Sponsored by [Les-Tilleuls.coop](https://les-tilleuls.coop).

Symfony UX Turbo has been inspired by [hotwired/turbo-rails](https://github.com/hotwired/turbo-rails)
and [sroze/live-twig](https://github.com/sroze/live-twig).
